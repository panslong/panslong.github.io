const e=JSON.parse('{"key":"v-0ef0d665","path":"/database/Redis/2023-11-21-Redis%E9%9B%86%E7%BE%A4.html","title":"Redis集群","lang":"zh-CN","frontmatter":{"title":"Redis集群","icon":"article","date":"2022-11-21T00:00:00.000Z","category":"Redis","tag":["Redis"],"description":"1.Redis主从 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。 1.1.主从集群结构 下图就是一个简单的Redis主从集群结构： 如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由： 如果是写操作，应该访问master节点，master会自动将数据同步给两个slave节点 如果是读操作，建议访问各个slave节点，从而分担并发压力","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-v2-demo.mrhope.site/database/Redis/2023-11-21-Redis%E9%9B%86%E7%BE%A4.html"}],["meta",{"property":"og:site_name","content":"七分熟"}],["meta",{"property":"og:title","content":"Redis集群"}],["meta",{"property":"og:description","content":"1.Redis主从 单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。 1.1.主从集群结构 下图就是一个简单的Redis主从集群结构： 如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由： 如果是写操作，应该访问master节点，master会自动将数据同步给两个slave节点 如果是读操作，建议访问各个slave节点，从而分担并发压力"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://vuepress-theme-hope-v2-demo.mrhope.site/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-13T01:59:03.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Redis集群"}],["meta",{"property":"article:author","content":"七分熟"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2022-11-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-12-13T01:59:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis集群\\",\\"image\\":[\\"https://vuepress-theme-hope-v2-demo.mrhope.site/\\"],\\"datePublished\\":\\"2022-11-21T00:00:00.000Z\\",\\"dateModified\\":\\"2023-12-13T01:59:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"七分熟\\",\\"url\\":\\"https://github.com/panslong\\"}]}"]]},"headers":[{"level":2,"title":"1.1.主从集群结构","slug":"_1-1-主从集群结构","link":"#_1-1-主从集群结构","children":[]},{"level":2,"title":"1.2.搭建主从集群","slug":"_1-2-搭建主从集群","link":"#_1-2-搭建主从集群","children":[{"level":3,"title":"1.2.1.启动多个Redis实例","slug":"_1-2-1-启动多个redis实例","link":"#_1-2-1-启动多个redis实例","children":[]},{"level":3,"title":"1.2.2.建立集群","slug":"_1-2-2-建立集群","link":"#_1-2-2-建立集群","children":[]},{"level":3,"title":"1.2.3.测试","slug":"_1-2-3-测试","link":"#_1-2-3-测试","children":[]}]},{"level":2,"title":"1.3.主从同步原理","slug":"_1-3-主从同步原理","link":"#_1-3-主从同步原理","children":[{"level":3,"title":"1.3.1.全量同步","slug":"_1-3-1-全量同步","link":"#_1-3-1-全量同步","children":[]},{"level":3,"title":"1.3.2.增量同步","slug":"_1-3-2-增量同步","link":"#_1-3-2-增量同步","children":[]},{"level":3,"title":"1.3.3.repl_baklog原理","slug":"_1-3-3-repl-baklog原理","link":"#_1-3-3-repl-baklog原理","children":[]}]},{"level":2,"title":"1.4.主从同步优化","slug":"_1-4-主从同步优化","link":"#_1-4-主从同步优化","children":[]},{"level":2,"title":"1.5总结","slug":"_1-5总结","link":"#_1-5总结","children":[]},{"level":2,"title":"2.1.哨兵工作原理","slug":"_2-1-哨兵工作原理","link":"#_2-1-哨兵工作原理","children":[{"level":3,"title":"2.1.1.哨兵作用","slug":"_2-1-1-哨兵作用","link":"#_2-1-1-哨兵作用","children":[]},{"level":3,"title":"2.1.2.状态监控","slug":"_2-1-2-状态监控","link":"#_2-1-2-状态监控","children":[]},{"level":3,"title":"2.1.3.选举leader","slug":"_2-1-3-选举leader","link":"#_2-1-3-选举leader","children":[]},{"level":3,"title":"2.1.4.failover","slug":"_2-1-4-failover","link":"#_2-1-4-failover","children":[]}]},{"level":2,"title":"2.2.搭建哨兵集群","slug":"_2-2-搭建哨兵集群","link":"#_2-2-搭建哨兵集群","children":[]},{"level":2,"title":"2.3总结","slug":"_2-3总结","link":"#_2-3总结","children":[]},{"level":2,"title":"2.4RedisTemplate连接哨兵集群","slug":"_2-4redistemplate连接哨兵集群","link":"#_2-4redistemplate连接哨兵集群","children":[{"level":3,"title":"2.4.1.引入依赖","slug":"_2-4-1-引入依赖","link":"#_2-4-1-引入依赖","children":[]},{"level":3,"title":"2.4.2.配置哨兵地址","slug":"_2-4-2-配置哨兵地址","link":"#_2-4-2-配置哨兵地址","children":[]},{"level":3,"title":"2.4.3.配置读写分离","slug":"_2-4-3-配置读写分离","link":"#_2-4-3-配置读写分离","children":[]}]},{"level":2,"title":"3.1.搭建分片集群","slug":"_3-1-搭建分片集群","link":"#_3-1-搭建分片集群","children":[{"level":3,"title":"3.1.1.集群配置","slug":"_3-1-1-集群配置","link":"#_3-1-1-集群配置","children":[]},{"level":3,"title":"3.1.2.启动集群","slug":"_3-1-2-启动集群","link":"#_3-1-2-启动集群","children":[]}]},{"level":2,"title":"3.2.散列插槽","slug":"_3-2-散列插槽","link":"#_3-2-散列插槽","children":[]},{"level":2,"title":"3.3.故障转移","slug":"_3-3-故障转移","link":"#_3-3-故障转移","children":[]},{"level":2,"title":"3.4.总结","slug":"_3-4-总结","link":"#_3-4-总结","children":[]},{"level":2,"title":"3.5.Java客户端连接分片集群","slug":"_3-5-java客户端连接分片集群","link":"#_3-5-java客户端连接分片集群","children":[]}],"git":{"createdTime":1702432743000,"updatedTime":1702432743000,"contributors":[{"name":"panshuilong","email":"1063589459@qq.com","commits":1}]},"readingTime":{"minutes":21.07,"words":6320},"filePathRelative":"database/Redis/2023-11-21-Redis集群.md","localizedDate":"2022年11月21日","excerpt":"<h1> 1.Redis主从</h1>\\n<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>\\n<h2> 1.1.主从集群结构</h2>\\n<p>下图就是一个简单的Redis主从集群结构：</p>\\n<figure><figcaption></figcaption></figure>\\n<p>如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由：</p>\\n<ul>\\n<li>如果是写操作，应该访问master节点，master会自动将数据同步给两个slave节点</li>\\n<li>如果是读操作，建议访问各个slave节点，从而分担并发压力</li>\\n</ul>","autoDesc":true}');export{e as data};
