import{_ as o}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as i,c as l,e as s,f as a,b as t,d as e}from"./app-de394487.js";const d="/assets/20231129105709-84d3d8f2.png",p="/assets/a57b508f-58c3-4e62-a959-008df2c411c9-53c88174.png",r="/assets/20231129110633-35588452.png",u="/assets/9d589758-818d-493c-8faa-8fe89bab9469-07b67210.png",v="/assets/f3c164a3-6693-415a-97bd-5708e1170ee6-0ac1c4f4.png",k="/assets/75f513f2-9896-406d-a4b3-11e031e73713-b4c99cc0.png",m="/assets/20231129111310-884b85f5.png",b="/assets/20231129111434-91358a3f.png",g="/assets/2021129115020-d25dafd4.jpeg",h="/assets/28388518-29bb-444e-8926-1399dc5dd47e-820871e2.png",f="/assets/1c900712-a9dc-4c32-b610-d9aaef30fd9f-fb8af6a3.png",q="/assets/20231129115610-de55d579.png",_="/assets/035f5abb-7089-416e-b870-0900097feb77-17bd4d59.png",y="/assets/18842291-3c4e-4374-a240-3d375388c133-5d867bc2.png",x="/assets/47838d95-cbbf-4194-a501-e21b86903a51-f471baa7.png",R="/assets/1bbdaeb8-0c52-4b9e-b991-7daac491c327-c3995a15.png",B="/assets/20231129141211-c8d31d31.png",w="/assets/13fee888-cb76-4c58-be0d-60ca919c6555-0eaab064.png",z={},D=e('<h1 id="_1-redis主从" tabindex="-1"><a class="header-anchor" href="#_1-redis主从" aria-hidden="true">#</a> 1.Redis主从</h1><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><h2 id="_1-1-主从集群结构" tabindex="-1"><a class="header-anchor" href="#_1-1-主从集群结构" aria-hidden="true">#</a> 1.1.主从集群结构</h2><p>下图就是一个简单的Redis主从集群结构：</p><figure><img src="'+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如图所示，集群中有一个master节点、两个slave节点（现在叫replica）。当我们通过Redis的Java客户端访问主从集群时，应该做好路由：</p><ul><li>如果是写操作，应该访问master节点，master会自动将数据同步给两个slave节点</li><li>如果是读操作，建议访问各个slave节点，从而分担并发压力</li></ul><h2 id="_1-2-搭建主从集群" tabindex="-1"><a class="header-anchor" href="#_1-2-搭建主从集群" aria-hidden="true">#</a> 1.2.搭建主从集群</h2><p>我们会在同一个虚拟机中利用3个Docker容器来搭建主从集群，容器信息如下：</p><table><thead><tr><th style="text-align:left;"><strong>容器名</strong></th><th style="text-align:left;"><strong>角色</strong></th><th style="text-align:left;"><strong>IP</strong></th><th style="text-align:left;"><strong>映射****端口</strong></th></tr></thead><tbody><tr><td style="text-align:left;">r1</td><td style="text-align:left;">master</td><td style="text-align:left;">192.168.100.101</td><td style="text-align:left;">7001</td></tr><tr><td style="text-align:left;">r2</td><td style="text-align:left;">slave</td><td style="text-align:left;">192.168.100.101</td><td style="text-align:left;">7002</td></tr><tr><td style="text-align:left;">r3</td><td style="text-align:left;">slave</td><td style="text-align:left;">192.168.100.101</td><td style="text-align:left;">7003</td></tr></tbody></table><h3 id="_1-2-1-启动多个redis实例" tabindex="-1"><a class="header-anchor" href="#_1-2-1-启动多个redis实例" aria-hidden="true">#</a> 1.2.1.启动多个Redis实例</h3><p>我们利用docker-compose文件来构建主从集群：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">r1</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r1
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r2
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7002&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r3</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r3
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7003&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将其上传至虚拟机的<code>/root/redis</code>目录下：</p><p>执行命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> compose up <span class="token parameter variable">-d</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看docker容器，发现都正常启动了：</p><figure><img src="`+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1-2-2-建立集群" tabindex="-1"><a class="header-anchor" href="#_1-2-2-建立集群" aria-hidden="true">#</a> 1.2.2.建立集群</h3><p>虽然我们启动了3个Redis实例，但是它们并没有形成主从关系。我们需要通过命令来配置主从关系：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># Redis5.0以前</span>
slaveof <span class="token operator">&lt;</span>masterip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterport<span class="token operator">&gt;</span>
<span class="token comment"># Redis5.0以后</span>
replicaof <span class="token operator">&lt;</span>masterip<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>masterport<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有临时和永久两种模式：</p><ul><li>永久生效：在redis.conf文件中利用<code>slaveof</code>命令指定<code>master</code>节点</li><li>临时生效：直接利用redis-cli控制台输入<code>slaveof</code>命令，指定<code>master</code>节点</li></ul><p>我们测试临时模式，首先连接<code>r2</code>，让其以<code>r1</code>为master</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 连接r2</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r2 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7002</span>
<span class="token comment"># 认r1主，也就是7001</span>
slaveof <span class="token number">192.168</span>.100.101 <span class="token number">7001</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后连接<code>r3</code>，让其以<code>r1</code>为master</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 连接r3</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r3 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7003</span>
<span class="token comment"># 认r1主，也就是7001</span>
slaveof <span class="token number">192.168</span>.100.101 <span class="token number">7001</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后连接<code>r1</code>，查看集群状态：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 连接r1</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r1 redis-cli <span class="token parameter variable">-p</span> <span class="token number">7001</span>
<span class="token comment"># 查看集群状态</span>
info replication
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:700<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> info replication
<span class="token comment"># Replication</span>
role:master
connected_slaves:2
slave0:ip<span class="token operator">=</span><span class="token number">192.168</span>.100.101,port<span class="token operator">=</span><span class="token number">7002</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">140</span>,lag<span class="token operator">=</span><span class="token number">1</span>
slave1:ip<span class="token operator">=</span><span class="token number">192.168</span>.10.101,port<span class="token operator">=</span><span class="token number">7003</span>,state<span class="token operator">=</span>online,offset<span class="token operator">=</span><span class="token number">140</span>,lag<span class="token operator">=</span><span class="token number">1</span>
master_failover_state:no-failover
master_replid:16d90568498908b322178ca12078114e6c518b86
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:140
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:140
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，当前节点<code>r1:7001</code>的角色是<code>master</code>，有两个slave与其连接：</p><ul><li><code>slave0</code>：<code>port</code>是<code>7002</code>，也就是<code>r2</code>节点</li><li><code>slave1</code>：<code>port</code>是<code>7003</code>，也就是<code>r3</code>节点</li></ul><h3 id="_1-2-3-测试" tabindex="-1"><a class="header-anchor" href="#_1-2-3-测试" aria-hidden="true">#</a> 1.2.3.测试</h3><p>依次在<code>r1</code>、<code>r2</code>、<code>r3</code>节点上执行下面命令：</p><div class="language-Bash line-numbers-mode" data-ext="Bash"><pre class="language-Bash"><code>set num 123

get num
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会发现，只有在<code>r1</code>这个节点上可以执行<code>set</code>命令（<strong>写操作</strong>），其它两个节点只能执行<code>get</code>命令（<strong>读操作</strong>）。也就是说读写操作已经分离了。</p><h2 id="_1-3-主从同步原理" tabindex="-1"><a class="header-anchor" href="#_1-3-主从同步原理" aria-hidden="true">#</a> 1.3.主从同步原理</h2><p>在刚才的主从测试中，我们发现<code>r1</code>上写入Redis的数据，在<code>r2</code>和<code>r3</code>上也能看到，这说明主从之间确实完成了数据同步。</p><p>那么这个同步是如何完成的呢？</p><h3 id="_1-3-1-全量同步" tabindex="-1"><a class="header-anchor" href="#_1-3-1-全量同步" aria-hidden="true">#</a> 1.3.1.全量同步</h3><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><figure><img src="`+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里有一个问题，<code>master</code>如何得知<code>salve</code>是否是第一次来同步呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><strong><code>Replication Id</code></strong>：简称<code>replid</code>，是数据集的标记，replid一致则是同一数据集。每个<code>master</code>都有唯一的<code>replid</code>，<code>slave</code>则会继承<code>master</code>节点的<code>replid</code></li><li><strong><code>offset</code></strong>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。<code>slave</code>完成同步时也会记录当前同步的<code>offset</code>。如果<code>slave</code>的<code>offset</code>小于<code>master</code>的<code>offset</code>，说明<code>slave</code>数据落后于<code>master</code>，需要更新。</li></ul><p>因此<code>slave</code>做数据同步，必须向<code>master</code>声明自己的<code>replication id </code>和<code>offset</code>，<code>master</code>才可以判断到底需要同步哪些数据。</p><p>由于我们在执行<code>slaveof</code>命令之前，所有redis节点都是<code>master</code>，有自己的<code>replid</code>和<code>offset</code>。</p><p>当我们第一次执行<code>slaveof</code>命令，与<code>master</code>建立主从关系时，发送的<code>replid</code>和<code>offset</code>是自己的，与<code>master</code>肯定不一致。</p><p><code>master</code>判断发现<code>slave</code>发送来的<code>replid</code>与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p><code>master</code>会将自己的<code>replid</code>和<code>offset</code>都发送给这个<code>slave</code>，<code>slave</code>保存这些信息到本地。自此以后<code>slave</code>的<code>replid</code>就与<code>master</code>一致了。</p><p>完整流程描述：</p><ul><li><code>slave</code>节点请求增量同步</li><li><code>master</code>节点判断<code>replid</code>，发现不一致，拒绝增量同步</li><li><code>master</code>将完整内存数据生成<code>RDB</code>，发送<code>RDB</code>到<code>slave</code></li><li><code>slave</code>清空本地数据，加载<code>master</code>的<code>RDB</code></li><li><code>master</code>将<code>RDB</code>期间的命令记录在<code>repl_baklog</code>，并持续将log中的命令发送给<code>slave</code></li><li><code>slave</code>执行接收到的命令，保持与<code>master</code>之间的同步</li></ul><h3 id="_1-3-2-增量同步" tabindex="-1"><a class="header-anchor" href="#_1-3-2-增量同步" aria-hidden="true">#</a> 1.3.2.增量同步</h3><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><h3 id="_1-3-3-repl-baklog原理" tabindex="-1"><a class="header-anchor" href="#_1-3-3-repl-baklog原理" aria-hidden="true">#</a> 1.3.3.repl_baklog原理</h3><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的<code>repl_baklog</code>文件了。这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p><code>repl_baklog</code>中会记录Redis处理过的命令及<code>offset</code>，包括master当前的<code>offset</code>，和slave已经拷贝到的<code>offset</code>：</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>直到数组被填满：</p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分</p><p>但是，如果slave出现网络阻塞，导致master的<code>offset</code>远远超过了slave的<code>offset</code>：</p><p>如果master继续写入新数据，master的<code>offset</code>就会覆盖<code>repl_baklog</code>中旧的数据，直到将slave现在的<code>offset</code>也覆盖：</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的<code>offset</code>都没有了，无法完成增量同步了。只能做<strong>全量同步</strong>。</p><p><code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于<code>repl_baklog</code>做增量同步，只能再次全量同步。</p><h2 id="_1-4-主从同步优化" tabindex="-1"><a class="header-anchor" href="#_1-4-主从同步优化" aria-hidden="true">#</a> 1.4.主从同步优化</h2><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li>在master中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高<code>repl_baklog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用<code>主-从-从</code>链式结构，减少master压力</li></ul><h2 id="_1-5总结" tabindex="-1"><a class="header-anchor" href="#_1-5总结" aria-hidden="true">#</a> 1.5总结</h2><p>简述全量同步和增量同步区别？</p><ul><li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li><li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li></ul><p>什么时候执行全量同步？</p><ul><li>slave节点第一次连接master节点时</li><li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li></ul><p>什么时候执行增量同步？</p><ul><li>slave节点断开又恢复，并且在<code>repl_baklog</code>中能找到offset时</li></ul><h1 id="_2-redis哨兵" tabindex="-1"><a class="header-anchor" href="#_2-redis哨兵" aria-hidden="true">#</a> 2.Redis哨兵</h1><p>主从结构中master节点的作用非常重要，一旦故障就会导致集群不可用。那么有什么办法能保证主从集群的高可用性呢？</p><h2 id="_2-1-哨兵工作原理" tabindex="-1"><a class="header-anchor" href="#_2-1-哨兵工作原理" aria-hidden="true">#</a> 2.1.哨兵工作原理</h2><p>Redis提供了<code>哨兵</code>（<code>Sentinel</code>）机制来监控主从集群监控状态，确保集群的高可用性。</p><h3 id="_2-1-1-哨兵作用" tabindex="-1"><a class="header-anchor" href="#_2-1-1-哨兵作用" aria-hidden="true">#</a> 2.1.1.哨兵作用</h3><p>哨兵集群作用原理图：</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>哨兵的作用如下：</p><ul><li><strong>状态监控</strong>：<code>Sentinel</code> 会不断检查您的<code>master</code>和<code>slave</code>是否按预期工作</li><li><strong>故障恢复（failover）</strong>：如果<code>master</code>故障，<code>Sentinel</code>会将一个<code>slave</code>提升为<code>master</code>。当故障实例恢复后会成为<code>slave</code></li><li><strong>状态通知</strong>：<code>Sentinel</code>充当<code>Redis</code>客户端的服务发现来源，当集群发生<code>failover</code>时，会将最新集群信息推送给<code>Redis</code>的客户端</li></ul><p>那么问题来了，<code>Sentinel</code>怎么知道一个Redis节点是否宕机呢？</p><h3 id="_2-1-2-状态监控" tabindex="-1"><a class="header-anchor" href="#_2-1-2-状态监控" aria-hidden="true">#</a> 2.1.2.状态监控</h3><p><code>Sentinel</code>基于心跳机制监测服务状态，每隔1秒向集群的每个节点发送ping命令，并通过实例的响应结果来做出判断：</p><ul><li><strong>主观下线（sdown）</strong>：如果某sentinel节点发现某Redis节点未在规定时间响应，则认为该节点主观下线。</li><li><strong>客观下线(odown)</strong>：若超过指定数量（通过<code>quorum</code>设置）的sentinel都认为该节点主观下线，则该节点客观下线。quorum值最好超过Sentinel节点数量的一半，Sentinel节点数量至少3台。</li></ul><p>如图：</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过<code>down-after-milliseconds * 10</code>则会排除该slave节点</li><li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举（默认都是1）。</li><li>如果<code>slave-prority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的<code>run_id</code>大小，越小优先级越高（<code>通过info server可以查看run_id</code>）。</li></ul><p>对应的官方文档如下：</p>',100),S={href:"https://redis.io/docs/management/sentinel/#replica-selection-and-priority",target:"_blank",rel:"noopener noreferrer"},E=e(`<p>问题来了，当选出一个新的master后，该如何实现身份切换呢？</p><p>大概分为两步：</p><ul><li>在多个<code>sentinel</code>中选举一个<code>leader</code></li><li>由<code>leader</code>执行<code>failover</code></li></ul><h3 id="_2-1-3-选举leader" tabindex="-1"><a class="header-anchor" href="#_2-1-3-选举leader" aria-hidden="true">#</a> 2.1.3.选举leader</h3><p>首先，Sentinel集群要选出一个执行<code>failover</code>的Sentinel节点，可以成为<code>leader</code>。要成为<code>leader</code>要满足两个条件：</p><ul><li>最先获得超过半数的投票</li><li>获得的投票数不小于<code>quorum</code>值</li></ul><p>而sentinel投票的原则有两条：</p><ul><li>优先投票给目前得票最多的</li><li>如果目前没有任何节点的票，就投给自己</li></ul><p>比如有3个sentinel节点，<code>s1</code>、<code>s2</code>、<code>s3</code>，假如<code>s2</code>先投票：</p><ul><li>此时发现没有任何人在投票，那就投给自己。<code>s2</code>得1票</li><li>接着<code>s1</code>和<code>s3</code>开始投票，发现目前<code>s2</code>票最多，于是也投给<code>s2</code>，<code>s2</code>得3票</li><li><code>s2</code>称为<code>leader</code>，开始故障转移</li></ul><p>不难看出，<strong>谁先<strong><strong>投票</strong></strong>，谁就会称为****leader</strong>，那什么时候会触发投票呢？</p><p>答案是<strong>第一个确认<strong><strong>master</strong></strong>客观下线的人会立刻发起<strong><strong>投票</strong></strong>，一定会成为****leader</strong>。</p><p>OK，<code>sentinel</code>找到<code>leader</code>以后，该如何完成<code>failover</code>呢？</p><h3 id="_2-1-4-failover" tabindex="-1"><a class="header-anchor" href="#_2-1-4-failover" aria-hidden="true">#</a> 2.1.4.failover</h3><p>我们举个例子，有一个集群，初始状态下7001为<code>master</code>，7002和7003为<code>slave</code>：</p><p>假如master发生故障，slave1当选。则故障转移的流程如下：</p><p>1）<code>sentinel</code>给备选的<code>slave1</code>节点发送<code>slaveof no one</code>命令，让该节点成为<code>master</code></p><p>2）<code>sentinel</code>给所有其它<code>slave</code>发送<code>slaveof 192.168.100.101 7002</code> 命令，让这些节点成为新<code>master</code>，也就是<code>7002</code>的<code>slave</code>节点，开始从新的<code>master</code>上同步数据。</p><p>3）最后，当故障节点恢复后会接收到哨兵信号，执行<code>slaveof 192.168.100.101 7002</code>命令，成为<code>slave</code>：</p><h2 id="_2-2-搭建哨兵集群" tabindex="-1"><a class="header-anchor" href="#_2-2-搭建哨兵集群" aria-hidden="true">#</a> 2.2.搭建哨兵集群</h2><p>首先，我们停掉之前的redis集群：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker-compose down
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，编写sentinel.conf文件：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>sentinel announce-ip <span class="token string">&quot;192.168.100.101&quot;</span>
sentinel monitor hmaster <span class="token number">192.168</span>.100.101 <span class="token number">7003</span> <span class="token number">2</span>
sentinel down-after-milliseconds hmaster <span class="token number">5000</span>
sentinel failover-timeout hmaster <span class="token number">60000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：</p><ul><li><code>sentinel announce-ip &quot;192.168.100.101&quot;</code>：声明当前sentinel的ip</li><li><code>sentinel monitor hmaster 192.168.100.101 7001 2</code>：指定集群的主节点信息 <ul><li><code>hmaster</code>：主节点名称，自定义，任意写</li><li><code>192.168.100.101 7001</code>：主节点的ip和端口</li><li><code>2</code>：认定<code>master</code>下线时的<code>quorum</code>值</li></ul></li><li><code>sentinel down-after-milliseconds hmaster 5000</code>：声明master节点超时多久后被标记下线</li><li><code>sentinel failover-timeout hmaster 60000</code>：在第一次故障转移失败后多久再次重试</li></ul><p>我们在虚拟机的<code>/root/redis</code>目录下新建3个文件夹：<code>s1</code>、<code>s2</code>、<code>s3</code>:</p><p>将<code>sentinel.conf</code>文件分别拷贝一份到3个文件夹中。</p><p>接着修改<code>docker-compose.yaml</code>文件，内容如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">r1</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r1
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r2
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7002&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--slaveof&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.150.101&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r3</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r3
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7003&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--slaveof&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;192.168.150.101&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">s1</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> s1
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /root/redis/s1<span class="token punctuation">:</span>/etc/redis
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-sentinel&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/etc/redis/sentinel.conf&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;27001&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">s2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> s2
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /root/redis/s2<span class="token punctuation">:</span>/etc/redis
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-sentinel&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/etc/redis/sentinel.conf&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;27002&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">s3</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> s3
    <span class="token key atrule">volumes</span><span class="token punctuation">:</span>
      <span class="token punctuation">-</span> /root/redis/s3<span class="token punctuation">:</span>/etc/redis
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-sentinel&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;/etc/redis/sentinel.conf&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;27003&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>直接运行命令，启动集群：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker-compose up -d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们以s1节点为例，查看其运行日志：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># Sentinel ID is 8e91bd24ea8e5eb2aee38f1cf796dcb26bb88acf</span>
<span class="token comment"># +monitor master hmaster 192.168.100.101 7001 quorum 2</span>
* +slave slave <span class="token number">192.168</span>.100.101:7003 <span class="token number">192.168</span>.100.101 <span class="token number">7003</span> @ hmaster <span class="token number">192.168</span>.100.101 <span class="token number">7001</span>
* +sentinel sentinel 5bafeb97fc16a82b431c339f67b015a51dad5e4f <span class="token number">192.168</span>.100.101 <span class="token number">27002</span> @ hmaster <span class="token number">192.168</span>.100.101 <span class="token number">7001</span>
* +sentinel sentinel 56546568a2f7977da36abd3d2d7324c6c3f06b8d <span class="token number">192.168</span>.100.101 <span class="token number">27003</span> @ hmaster <span class="token number">192.168</span>.100.101 <span class="token number">7001</span>
* +slave slave <span class="token number">192.168</span>.100.101:7002 <span class="token number">192.168</span>.100.101 <span class="token number">7002</span> @ hmaster <span class="token number">192.168</span>.100.101 <span class="token number">7001</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到<code>sentinel</code>已经联系到了<code>7001</code>这个节点，并且与其它几个哨兵也建立了链接。哨兵信息如下：</p><ul><li><code>27001</code>：<code>Sentinel ID</code>是<code>8e91bd24ea8e5eb2aee38f1cf796dcb26bb88acf</code></li><li><code>27002</code>：<code>Sentinel ID</code>是<code>5bafeb97fc16a82b431c339f67b015a51dad5e4f</code></li><li><code>27003</code>：<code>Sentinel ID</code>是<code>56546568a2f7977da36abd3d2d7324c6c3f06b8d</code></li></ul><h2 id="_2-3总结" tabindex="-1"><a class="header-anchor" href="#_2-3总结" aria-hidden="true">#</a> 2.3总结</h2><p>Sentinel的三个作用是什么？</p><ul><li>集群监控</li><li>故障恢复</li><li>状态通知</li></ul><p>Sentinel如何判断一个redis实例是否健康？</p><ul><li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线（<code>sdown</code>）</li><li>如果大多数sentinel都认为实例主观下线，则判定服务客观下线（<code>odown</code>）</li></ul><p>故障转移步骤有哪些？</p><ul><li>首先要在<code>sentinel</code>中选出一个<code>leader</code>，由leader执行<code>failover</code></li><li>选定一个<code>slave</code>作为新的<code>master</code>，执行<code>slaveof noone</code>，切换到master模式</li><li>然后让所有节点都执行<code>slaveof</code> 新master</li><li>修改故障节点配置，添加<code>slaveof</code> 新master</li></ul><p>sentinel选举leader的依据是什么？</p><ul><li>票数超过sentinel节点数量1半</li><li>票数超过quorum数量</li><li>一般情况下最先发起failover的节点会当选</li></ul><p>sentinel从slave中选取master的依据是什么？</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过<code>down-after-milliseconds * 10</code>则会排除该slave节点</li><li>然后判断slave节点的<code>slave-priority</code>值，越小优先级越高，如果是0则永不参与选举（默认都是1）。</li><li>如果<code>slave-prority</code>一样，则判断slave节点的<code>offset</code>值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的<code>run_id</code>大小，越小优先级越高（<code>通过info server可以查看run_id</code>）。</li></ul><h2 id="_2-4redistemplate连接哨兵集群" tabindex="-1"><a class="header-anchor" href="#_2-4redistemplate连接哨兵集群" aria-hidden="true">#</a> 2.4RedisTemplate连接哨兵集群</h2><p>分为三步：</p><ul><li>1）引入依赖</li><li>2）配置哨兵地址</li><li>3）配置读写分离</li></ul><h3 id="_2-4-1-引入依赖" tabindex="-1"><a class="header-anchor" href="#_2-4-1-引入依赖" aria-hidden="true">#</a> 2.4.1.引入依赖</h3><p>就是SpringDataRedis的依赖：</p><div class="language-XML line-numbers-mode" data-ext="XML"><pre class="language-XML"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-2-配置哨兵地址" tabindex="-1"><a class="header-anchor" href="#_2-4-2-配置哨兵地址" aria-hidden="true">#</a> 2.4.2.配置哨兵地址</h3><p>连接哨兵集群与传统单点模式不同，不再需要设置每一个redis的地址，而是直接指定哨兵地址：</p><div class="language-YAML line-numbers-mode" data-ext="YAML"><pre class="language-YAML"><code>spring:
  redis:
    sentinel:
      master: hmaster # 集群名
      nodes: # 哨兵地址列表
        - 192.168.100.101:27001
        - 192.168.100.101:27002
        - 192.168.100.101:27003
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-3-配置读写分离" tabindex="-1"><a class="header-anchor" href="#_2-4-3-配置读写分离" aria-hidden="true">#</a> 2.4.3.配置读写分离</h3><p>最后，还要配置读写分离，让java客户端将写请求发送到master节点，读请求发送到slave节点。定义一个bean即可：</p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>@Bean
public LettuceClientConfigurationBuilderCustomizer clientConfigurationBuilderCustomizer(){
    return clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li><code>MASTER</code>：从主节点读取</li><li><code>MASTER_PREFERRED</code>：优先从<code>master</code>节点读取，<code>master</code>不可用才读取<code>slave</code></li><li><code>REPLICA</code>：从<code>slave</code>节点读取</li><li><code>REPLICA_PREFERRED</code>：优先从<code>slave</code>节点读取，所有的<code>slave</code>都不可用才读取<code>master</code></li></ul><h1 id="_3-redis分片集群" tabindex="-1"><a class="header-anchor" href="#_3-redis分片集群" aria-hidden="true">#</a> 3.Redis分片集群</h1><p>主从模式可以解决高可用、高并发读的问题。但依然有两个问题没有解决：</p><ul><li>海量数据存储</li><li>高并发写</li></ul><p>要解决这两个问题就需要用到分片集群了。分片的意思，就是把数据拆分存储到不同节点，这样整个集群的存储数据量就更大了。</p><p>Redis分片集群的结构如图：</p><figure><img src="`+g+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>分片集群特征：</p><ul><li>集群中有多个master，每个master保存不同分片数据 ，解决海量数据存储问题</li><li>每个master都可以有多个slave节点 ，确保高可用</li><li>master之间通过ping监测彼此健康状态 ，类似哨兵作用</li><li>客户端请求可以访问集群任意节点，最终都会被转发到数据所在节点</li></ul><h2 id="_3-1-搭建分片集群" tabindex="-1"><a class="header-anchor" href="#_3-1-搭建分片集群" aria-hidden="true">#</a> 3.1.搭建分片集群</h2><p>Redis分片集群最少也需要3个master节点，由于我们的机器性能有限，我们只给每个master配置1个slave，形成最小的分片集群：</p><p>计划部署的节点信息如下：</p><table><thead><tr><th>容器名</th><th>角色</th><th>IP</th><th>映射端口</th></tr></thead><tbody><tr><td>r1</td><td>master</td><td>192.168.100.101</td><td>7001</td></tr><tr><td>r2</td><td>master</td><td>192.168.100.101</td><td>7002</td></tr><tr><td>r3</td><td>master</td><td>192.168.100.101</td><td>7003</td></tr><tr><td>r4</td><td>slave</td><td>192.168.100.101</td><td>7004</td></tr><tr><td>r5</td><td>slave</td><td>192.168.100.101</td><td>7005</td></tr><tr><td>r6</td><td>slave</td><td>192.168.100.101</td><td>7006</td></tr></tbody></table><h3 id="_3-1-1-集群配置" tabindex="-1"><a class="header-anchor" href="#_3-1-1-集群配置" aria-hidden="true">#</a> 3.1.1.集群配置</h3><p>分片集群中的Redis节点必须开启集群模式，一般在配置文件中添加下面参数：</p><div class="language-Bash line-numbers-mode" data-ext="Bash"><pre class="language-Bash"><code>port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>cluster-enabled</code>：是否开启集群模式</li><li><code>cluster-config-file</code>：集群模式的配置文件名称，无需手动创建，由集群自动维护</li><li><code>cluster-node-timeout</code>：集群中节点之间心跳超时时间</li></ul><p>一般搭建部署集群肯定是给每个节点都配置上述参数，不过考虑到我们计划用<code>docker-compose</code>部署，因此可以直接在启动命令中指定参数，偷个懒。</p><p>在虚拟机的<code>/root</code>目录下新建一个<code>redis-cluster</code>目录，然后在其中新建一个<code>docker-compose.yaml</code>文件，内容如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">&quot;3.2&quot;</span>

<span class="token key atrule">services</span><span class="token punctuation">:</span>
  <span class="token key atrule">r1</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r1
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7001&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-enabled&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yes&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-config-file&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;node.conf&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r2</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r2
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7002&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-enabled&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yes&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-config-file&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;node.conf&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r3</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r3
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7003&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-enabled&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yes&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-config-file&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;node.conf&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r4</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r4
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7004&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-enabled&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yes&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-config-file&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;node.conf&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r5</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r5
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7005&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-enabled&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yes&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-config-file&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;node.conf&quot;</span><span class="token punctuation">]</span>
  <span class="token key atrule">r6</span><span class="token punctuation">:</span>
    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis
    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> r6
    <span class="token key atrule">network_mode</span><span class="token punctuation">:</span> <span class="token string">&quot;host&quot;</span>
    <span class="token key atrule">entrypoint</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;redis-server&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--port&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;7006&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-enabled&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;yes&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;--cluster-config-file&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;node.conf&quot;</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意</strong>：使用Docker部署Redis集群，network模式必须采用host</p><h3 id="_3-1-2-启动集群" tabindex="-1"><a class="header-anchor" href="#_3-1-2-启动集群" aria-hidden="true">#</a> 3.1.2.启动集群</h3><p>进入<code>/root/redis-cluster</code>目录，使用命令启动redis：</p><div class="language-Bash line-numbers-mode" data-ext="Bash"><pre class="language-Bash"><code>docker-compose up -d
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>启动成功，可以通过命令查看启动进程：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> redis
<span class="token comment"># 结果：</span>
root       <span class="token number">4822</span>   <span class="token number">4743</span>  <span class="token number">0</span> <span class="token number">14</span>:29 ?        00:00:02 redis-server *:7002 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>
root       <span class="token number">4827</span>   <span class="token number">4745</span>  <span class="token number">0</span> <span class="token number">14</span>:29 ?        00:00:01 redis-server *:7005 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>
root       <span class="token number">4897</span>   <span class="token number">4778</span>  <span class="token number">0</span> <span class="token number">14</span>:29 ?        00:00:01 redis-server *:7004 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>
root       <span class="token number">4903</span>   <span class="token number">4759</span>  <span class="token number">0</span> <span class="token number">14</span>:29 ?        00:00:01 redis-server *:7006 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>
root       <span class="token number">4905</span>   <span class="token number">4775</span>  <span class="token number">0</span> <span class="token number">14</span>:29 ?        00:00:02 redis-server *:7001 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>
root       <span class="token number">4912</span>   <span class="token number">4732</span>  <span class="token number">0</span> <span class="token number">14</span>:29 ?        00:00:01 redis-server *:7003 <span class="token punctuation">[</span>cluster<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以发现每个redis节点都以cluster模式运行。不过节点与节点之间并未建立连接。</p><p>接下来，我们使用命令创建集群：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 进入任意节点容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> r1 <span class="token function">bash</span>
<span class="token comment"># 然后，执行命令</span>
redis-cli <span class="token parameter variable">--cluster</span> create --cluster-replicas <span class="token number">1</span> <span class="token punctuation">\\</span>
<span class="token number">192.168</span>.100.101:7001 <span class="token number">192.168</span>.100.101:7002 <span class="token number">192.168</span>.100.101:7003 <span class="token punctuation">\\</span>
<span class="token number">192.168</span>.100.101:7004 <span class="token number">192.168</span>.100.101:7005 <span class="token number">192.168</span>.100.101:7006
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>命令说明：</p><ul><li><p><code>redis-cli --cluster</code>：代表集群操作命令</p></li><li><p><code>create</code>：代表是创建集群</p></li><li><p><code>--cluster-replicas 1</code> ：指定集群中每个<code>master</code>的副本个数为1</p><ul><li>此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是<code>master</code>的数量<code>n</code>。因此节点列表中的前<code>n</code>个节点就是<code>master</code>，其它节点都是<code>slave</code>节点，随机分配到不同<code>master</code></li></ul><p>输入命令后控制台会弹出下面的信息：</p><figure><img src="`+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li></ul><p>这里展示了集群中<code>master</code>与<code>slave</code>节点分配情况，并询问你是否同意。节点信息如下：</p><ul><li><code>7001</code>是<code>master</code>，节点<code>id</code>后6位是<code>da134f</code></li><li><code>7002</code>是<code>master</code>，节点<code>id</code>后6位是<code>862fa0</code></li><li><code>7003</code>是<code>master</code>，节点<code>id</code>后6位是<code>ad5083</code></li><li><code>7004</code>是<code>slave</code>，节点<code>id</code>后6位是<code>391f8b</code>，认<code>ad5083</code>（7003）为<code>master</code></li><li><code>7005</code>是<code>slave</code>，节点<code>id</code>后6位是<code>e152cd</code>，认<code>da134f</code>（7001）为<code>master</code></li><li><code>7006</code>是<code>slave</code>，节点<code>id</code>后6位是<code>4a018a</code>，认<code>862fa0</code>（7002）为<code>master</code></li></ul><p>输入<code>yes</code>然后回车。会发现集群开始创建，并输出下列信息：</p><figure><img src="'+f+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接着，我们可以通过命令查看集群状态：</p><div class="language-Bash line-numbers-mode" data-ext="Bash"><pre class="language-Bash"><code>redis-cli -p 7001 cluster nodes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><figure><img src="`+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="_3-2-散列插槽" tabindex="-1"><a class="header-anchor" href="#_3-2-散列插槽" aria-hidden="true">#</a> 3.2.散列插槽</h2><p>数据要分片存储到不同的Redis节点，肯定需要有分片的依据，这样下次查询的时候才能知道去哪个节点查询。很多数据分片都会采用一致性hash算法。而Redis则是利用散列插槽（<strong><code>hash slot</code></strong>）的方式实现数据分片。</p><p>详见官方文档：</p>',102),I={href:"https://redis.io/docs/management/scaling/#redis-cluster-101",target:"_blank",rel:"noopener noreferrer"},L=e('<p>在Redis集群中，共有16384个<code>hash slots</code>，集群中的每一个master节点都会分配一定数量的<code>hash slots</code>。具体的分配在集群创建时就已经指定了：</p><figure><img src="'+_+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如图中所示：</p><ul><li>Master[0]，本例中就是7001节点，分配到的插槽是0~5460</li><li>Master[1]，本例中就是7002节点，分配到的插槽是5461~10922</li><li>Master[2]，本例中就是7003节点，分配到的插槽是10923~16383</li></ul><p>当我们读写数据时，Redis基于<code>CRC16</code> 算法对<code>key</code>做<code>hash</code>运算，得到的结果与<code>16384</code>取余，就计算出了这个<code>key</code>的<code>slot</code>值。然后到<code>slot</code>所在的Redis节点执行读写操作。</p><p>不过<code>hash slot</code>的计算也分两种情况：</p><ul><li>当<code>key</code>中包含<code>{}</code>时，根据<code>{}</code>之间的字符串计算<code>hash slot</code></li><li>当<code>key</code>中不包含<code>{}</code>时，则根据整个<code>key</code>字符串计算<code>hash slot</code></li></ul><p>例如：</p><ul><li>key是<code>user</code>，则根据<code>user</code>来计算hash slot</li><li>key是<code>user:{age}</code>，则根据<code>age</code>来计算hash slot</li></ul><p>我们来测试一下，先于<code>7001</code>建立连接：</p><div class="language-Bash line-numbers-mode" data-ext="Bash"><pre class="language-Bash"><code># 进入容器
docker exec -it r1 bash
# 进入redis-cli
redis-cli -p 7001
# 测试
set user jack
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会发现报错了：</p><figure><img src="`+y+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>提示我们<code>MOVED 5474</code>，其实就是经过计算，得出<code>user</code>这个<code>key</code>的<code>hash slot</code> 是<code>5474</code>，而<code>5474</code>是在<code>7002</code>节点，不能在<code>7001</code>上写入！！</p><p>说好的任意节点都可以读写呢？</p><p>这是因为我们连接的方式有问题，连接集群时，要加<code>-c</code>参数：</p><div class="language-Bash line-numbers-mode" data-ext="Bash"><pre class="language-Bash"><code># 通过7001连接集群
redis-cli -c -p 7001
# 存入数据
set user jack
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：</p><figure><img src="`+x+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，客户端自动跳转到了<code>5474</code>这个<code>slot</code>所在的<code>7002</code>节点。</p><p>现在，我们添加一个新的key，这次加上<code>{}</code>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 试一下key中带{}</span>
<span class="token builtin class-name">set</span> user:<span class="token punctuation">{</span>age<span class="token punctuation">}</span> <span class="token number">21</span>

<span class="token comment"># 再试一下key中不带{}</span>
<span class="token builtin class-name">set</span> age <span class="token number">20</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结果如下：</p><figure><img src="`+R+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到<code>user:{age}</code>和<code>age</code>计算出的<code>slot</code>都是<code>741</code>。</p><h2 id="_3-3-故障转移" tabindex="-1"><a class="header-anchor" href="#_3-3-故障转移" aria-hidden="true">#</a> 3.3.故障转移</h2><p>分片集群的节点之间会互相通过ping的方式做心跳检测，超时未回应的节点会被标记为下线状态。当发现master下线时，会将这个master的某个slave提升为master</p><p>我们先打开一个控制台窗口，利用命令监测集群状态：</p><div class="language-Bash line-numbers-mode" data-ext="Bash"><pre class="language-Bash"><code>watch docker exec -it r1 redis-cli -p 7001 cluster nodes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令前面的watch可以每隔一段时间刷新执行结果，方便我们实时监控集群状态变化。</p><p>接着，我们故技重施，利用命令让某个master节点休眠。比如这里我们让<code>7002</code>节点休眠，打开一个新的ssh控制台，输入下面命令：</p><div class="language-Bash line-numbers-mode" data-ext="Bash"><pre class="language-Bash"><code>docker exec -it r2 redis-cli -p 7002 DEBUG sleep 30
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可以观察到，集群发现7002宕机，标记为下线：</p><figure><img src="`+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>过了一段时间后，7002原本的小弟7006变成了<code>master</code>：</p><figure><img src="'+w+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>而7002被标记为<code>slave</code>，而且其<code>master</code>正好是7006，主从地位互换。</p><h2 id="_3-4-总结" tabindex="-1"><a class="header-anchor" href="#_3-4-总结" aria-hidden="true">#</a> 3.4.总结</h2><p>Redis分片集群如何判断某个key应该在哪个实例？</p><ul><li>将16384个插槽分配到不同的实例</li><li>根据key计算哈希值，对16384取余</li><li>余数作为插槽，寻找插槽所在实例即可</li></ul><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>Redis计算key的插槽值时会判断key中是否包含<code>{}</code>，如果有则基于<code>{}</code>内的字符计算插槽</li><li>数据的key中可以加入<code>{类型}</code>，例如key都以<code>{typeId}</code>为前缀，这样同类型数据计算的插槽一定相同</li></ul><h2 id="_3-5-java客户端连接分片集群" tabindex="-1"><a class="header-anchor" href="#_3-5-java客户端连接分片集群" aria-hidden="true">#</a> 3.5.Java客户端连接分片集群</h2><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致，参考<code>2.5节</code>：</p><p>1）引入redis的starter依赖</p><p>2）配置分片集群地址</p><p>3）配置读写分离</p><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><div class="language-YAML line-numbers-mode" data-ext="YAML"><pre class="language-YAML"><code>spring:
  redis:
    cluster:
      nodes:
        - 192.168.150.101:7001
        - 192.168.150.101:7002
        - 192.168.150.101:7003
        - 192.168.150.101:8001
        - 192.168.150.101:8002
        - 192.168.150.101:8003
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,49);function M(C,A){const n=c("ExternalLinkIcon");return i(),l("div",null,[D,s("p",null,[s("a",S,[a("https://redis.io/docs/management/sentinel/#replica-selection-and-priority"),t(n)])]),E,s("p",null,[s("a",I,[a("https://redis.io/docs/management/scaling/#redis-cluster-101"),t(n)])]),L])}const Y=o(z,[["render",M],["__file","2023-11-21-Redis集群.html.vue"]]);export{Y as default};
