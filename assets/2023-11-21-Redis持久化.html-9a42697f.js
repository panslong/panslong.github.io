import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,d as n}from"./app-de394487.js";const t="/assets/image-20210725144536958-981d82c0.png",i="/assets/image-20210725144725943-25f555fc.png",d="/assets/image-20210725151319695-ac3eab79.png",r="/assets/image-20210725151543640-eeea19b7.png",l="/assets/image-20210725151729118-d827d93a.png",p="/assets/20231121155417-f364e6a5.png",o={},c=n('<h1 id="redis持久化" tabindex="-1"><a class="header-anchor" href="#redis持久化" aria-hidden="true">#</a> Redis持久化</h1><p>Redis有两种持久化方案：</p><ul><li>RDB持久化</li><li>AOF持久化</li></ul><h2 id="_1-rdb持久化" tabindex="-1"><a class="header-anchor" href="#_1-rdb持久化" aria-hidden="true">#</a> 1.RDB持久化</h2><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p><h3 id="_1-1-执行时机" tabindex="-1"><a class="header-anchor" href="#_1-1-执行时机" aria-hidden="true">#</a> 1.1.执行时机</h3><p>RDB持久化在四种情况下会执行：</p><ul><li>执行save命令</li><li>执行bgsave命令</li><li>Redis停机时</li><li>触发RDB条件时</li></ul><p><strong>1）save命令</strong></p><p>执行下面的命令，可以立即执行一次RDB：</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p><p><strong>2）bgsave命令</strong></p><p>下面的命令可以异步执行RDB：</p><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p><p><strong>3）停机时</strong></p><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><p><strong>4）触发RDB条件</strong></p><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">900 1  </span>
<span class="token comment"># 300 秒之内，对数据库进行了至少 10 次修改</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">300 10  </span>
<span class="token comment"># 60 秒之内，对数据库进行了至少 10000 次修改。</span>
<span class="token key attr-name">save</span> <span class="token value attr-value">60 10000 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>RDB的其它配置也可以在redis.conf文件中设置：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span>
<span class="token key attr-name">rdbcompression</span> <span class="token value attr-value">yes</span>

<span class="token comment"># RDB文件名称</span>
<span class="token key attr-name">dbfilename</span> <span class="token value attr-value">dump.rdb  </span>

<span class="token comment"># 文件保存的路径目录</span>
<span class="token key attr-name">dir</span> <span class="token value attr-value">./ </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis 的快照是<strong>全量快照</strong>，也就是说每次执行快照，都是把内存中的「所有数据」都记录到磁盘中。</p><p>所以可以认为，执行快照是一个比较重的操作，如果频率太频繁，可能会对 Redis 性能产生影响。如果频率太低，服务器故障时，丢失的数据会更多。</p><p>通常可能设置至少 5 分钟才保存一次快照，这时如果 Redis 出现宕机等情况，则意味着最多可能丢失 5 分钟数据。</p><h3 id="_1-2-rdb原理" tabindex="-1"><a class="header-anchor" href="#_1-2-rdb原理" aria-hidden="true">#</a> 1.2.RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p><p>fork采用的是copy-on-write技术：执行 bgsave 命令的时候，会通过 <code>fork()</code> 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个。</p><ul><li>当主进程执行读操作时，访问共享内存；</li><li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li></ul><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>bgsave 快照过程中，如果主线程修改了共享数据，<strong>发生了写时复制后，RDB 快照保存的是原本的内存数据</strong>，而主线程刚修改的数据，是没办法在这一时间写入 RDB 文件的，只能交由下一次的 bgsave 快照。</p><h3 id="_1-3-小结" tabindex="-1"><a class="header-anchor" href="#_1-3-小结" aria-hidden="true">#</a> 1.3.小结</h3><p>RDB方式bgsave的基本流程？</p><ul><li>fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p>RDB会在什么时候执行？save 60 1000代表什么含义？</p><ul><li>默认是服务停止时</li><li>代表60秒内至少执行1000次修改则触发RDB</li></ul><p>RDB的缺点？</p><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h2 id="_2-aof持久化" tabindex="-1"><a class="header-anchor" href="#_2-aof持久化" aria-hidden="true">#</a> 2.AOF持久化</h2><h3 id="_2-1-aof原理" tabindex="-1"><a class="header-anchor" href="#_2-1-aof原理" aria-hidden="true">#</a> 2.1.AOF原理</h3><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p><figure><img src="'+r+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-2-aof配置" tabindex="-1"><a class="header-anchor" href="#_2-2-aof配置" aria-hidden="true">#</a> 2.2.AOF配置</h3><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 是否开启AOF功能，默认是no</span>
<span class="token key attr-name">appendonly</span> <span class="token value attr-value">yes</span>
<span class="token comment"># AOF文件的名称</span>
<span class="token key attr-name">appendfilename</span> <span class="token value attr-value">&quot;appendonly.aof&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># 表示每执行一次写命令，立即记录到AOF文件</span>
<span class="token key attr-name">appendfsync</span> <span class="token value attr-value">always </span>
<span class="token comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span>
<span class="token key attr-name">appendfsync</span> <span class="token value attr-value">everysec </span>
<span class="token comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span>
<span class="token key attr-name">appendfsync</span> <span class="token value attr-value">no</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三种策略对比：</p><table><thead><tr><th>配置项</th><th>刷盘时机</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>always</td><td>同步刷盘</td><td>可靠性高，几乎不丢数据</td><td>性能影响大</td></tr><tr><td>everysec</td><td>每秒刷盘</td><td>性能适中</td><td>最多丢失一秒数据</td></tr><tr><td>no</td><td>操作系统控制</td><td>性能最好</td><td>可靠性差，可能丢失大量数据</td></tr></tbody></table><h3 id="_2-3-aof文件重写" tabindex="-1"><a class="header-anchor" href="#_2-3-aof文件重写" aria-hidden="true">#</a> 2.3.AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><figure><img src="`+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span>
<span class="token key attr-name">auto-aof-rewrite-percentage</span> <span class="token value attr-value">100</span>
<span class="token comment"># AOF文件体积最小多大以上才触发重写 </span>
<span class="token key attr-name">auto-aof-rewrite-min-size</span> <span class="token value attr-value">64mb </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-rdb与aof对比" tabindex="-1"><a class="header-anchor" href="#_3-rdb与aof对比" aria-hidden="true">#</a> 3.RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>记录每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>很快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，因为数据完整性不如AOF</td><td>高，因为数据完整性高</td></tr><tr><td>系统资源占用</td><td>高，大量CPU和内存消耗</td><td>低，主要是磁盘IO资源，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td>可以容忍数分钟数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高</td></tr></tbody></table><h2 id="_4-rdb-和-aof-合体" tabindex="-1"><a class="header-anchor" href="#_4-rdb-和-aof-合体" aria-hidden="true">#</a> 4.RDB 和 AOF 合体</h2><p>尽管 RDB 比 AOF 的数据恢复速度快，但是快照的频率不好把握：</p><ul><li>如果频率太低，两次快照间一旦服务器发生宕机，就可能会比较多的数据丢失；</li><li>如果频率太高，频繁写入磁盘和创建子进程会带来额外的性能开销。</li></ul><p>那有没有什么方法不仅有 RDB 恢复速度快的优点和，又有 AOF 丢失数据少的优点呢？</p><p>当然有，那就是将 RDB 和 AOF 合体使用，这个方法是在 Redis 4.0 提出的，该方法叫<strong>混合使用 AOF 日志和内存快照</strong>，也叫混合持久化。</p><p>如果想要开启混合持久化功能，可以在 Redis 配置文件将下面这个配置项设置成 yes：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>aof-use-rdb-preamble yes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>混合持久化工作在 <strong>AOF 日志重写过程</strong>。</p><p>当开启了混合持久化时，在 AOF 重写日志时，<code>fork</code> 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。</p><p>也就是说，使用了混合持久化，AOF 文件的<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。</p><figure><img src="`+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这样的好处在于，重启 Redis 加载数据的时候，由于前半部分是 RDB 内容，这样加载的时候速度会很快。</p><p>加载完 RDB 的内容后，才会加载后半部分的 AOF 内容，这里的内容是 Redis 后台子进程重写 AOF 期间，主线程处理的操作命令，可以使得<strong>数据更少的丢失</strong>。</p>',71),u=[c];function v(m,g){return a(),s("div",null,u)}const f=e(o,[["render",v],["__file","2023-11-21-Redis持久化.html.vue"]]);export{f as default};
